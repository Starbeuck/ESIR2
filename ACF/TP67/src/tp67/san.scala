// Code generated by Isabelle
package tp67

import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to Int.int
object AutomaticConversion{ 
	implicit def int2int(i:utilities.Datatype.Int.int):Int.int =
			i match {
			case utilities.Datatype.Int.int_of_integer(i)=>Int.int_of_integer(i)
	}
}
import AutomaticConversion._  


object Int {

abstract sealed class int
final case class int_of_integer(a: BigInt) extends int

} /* object Int */

object Product_Type {

def equal_bool(p: Boolean, pa: Boolean): Boolean = (p, pa) match {
  case (p, true) => p
  case (p, false) => ! p
  case (true, p) => p
  case (false, p) => ! p
}

} /* object Product_Type */

object tp67 {

abstract sealed class quelquechose
final case class Indefini() extends quelquechose
final case class Tuple(a: Int.int, b: Int.int) extends quelquechose

def san4(x0: statement, st: List[(List[Char], quelquechose)]):
      (List[(List[Char], quelquechose)], Boolean)
  =
  (x0, st) match {
  case (Seq(x, xs), st) =>
    {
      val (a, b): (List[(List[Char], quelquechose)], Boolean) = san4(x, st);
      (if (Product_Type.equal_bool(b, false)) (st, false) else san4(xs, a))
    }
  case (If(uu, s1, s2), st) =>
    {
      val (a, b): (List[(List[Char], quelquechose)], Boolean) = san4(s1, st);
      (if (Product_Type.equal_bool(b, false)) (a, false)
        else {
               val (c, d): (List[(List[Char], quelquechose)], Boolean) =
                 san4(s2, a);
               (if (Product_Type.equal_bool(d, false)) (c, false)
                 else (a, true))
             })
    }
  case (Read(s1), st) => ((s1, Indefini()) :: st, true)
  case (Print(uv), st) => (st, true)
  case (Aff(v, va), st) => (st, true)
  case (Exec(v), st) => (st, true)
  case (Skip, st) => (st, true)
}

} /* object tp67 */
